<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../sc-socket/sc-socket.html">
<link rel="import" href="../sc-json-stable-stringify/sc-json-stable-stringify.html">

<dom-module id="sc-collection">
  <template>
    <sc-socket socket="{{socket}}"></sc-socket>
  </template>

  <script>
    Polymer({
      is: 'sc-collection',

      properties: {
        isReady: {
          type: Boolean,
          value: false
        },
        resourceType: {
          type: String,
          observer: 'loadValueObserver'
        },
        resourceView: {
          type: String,
          observer: 'loadValueObserver'
        },
        resourceValue: {
          type: Array,
          value: [],
          notify: true
        },
        resourcePageOffset: {
          type: Number,
          value: 0,
          notify: true,
          observer: 'loadValueObserver'
        },
        resourcePageSize: {
          type: Number,
          value: 10,
          notify: true,
          observer: 'loadValueObserver'
        },
        resourceIsLastPage: {
          type: Boolean,
          notify: true
        },
        resourcePredicateData: {
          type: Object,
          observer: 'loadValueObserver'
        },
        resourceCount: {
          type: Number,
          notify: true
        },
        getCount: {
          type: Boolean,
          value: true,
          observer: 'loadValueObserver'
        },
        disableRealtime: {
          type: Boolean,
          value: false,
          observer: 'realtimeModeObserver'
        },
        writeOnly: {
          type: Boolean,
          value: false
        },
        optimize: {
          type: Boolean,
          value: false
        },
        socket: {
          type: Object,
          observer: 'loadValueObserver'
        },
        viewChannel: {
          type: Object
        },
        typeChannel: {
          type: Object
        }
      },

      loadValueObserver: function () {
        if (this.socket && this.resourceType != null && this.resourceView != null && !this.writeOnly && this.resourcePredicateData !== undefined) {
          this.loadValue();
        }
      },

      loadValue: function () {
        var self = this;

        if (this.writeOnly) {
          throw new Error('Cannot load values for an sc-collection declared as write-only');
        }

        if (this.socket) {
          this.cleanupChannels();

          // Load values for the collection.
          this.loadData = function () {
            var query = {
              type: self.resourceType
            };
            query.offset = self.resourcePageOffset || 0;
            if (self.resourceView != null) {
              query.view = self.resourceView;
            }
            if (self.resourcePredicateData != null) {
              query.predicateData = self.resourcePredicateData;
            }
            if (self.resourcePageSize) {
              query.pageSize = self.resourcePageSize;
            }
            if (self.getCount) {
              query.getCount = true;
            }

            self.socket.emit('read', query, function (err, result) {
              if (err) {
                throw new Error(err);
              } else {
                var existingItemsMap = {};
                var currentItems = self.resourceValue;
                var len = currentItems.length;

                for (var h = 0; h < len; h++) {
                  existingItemsMap[currentItems[h].id] = currentItems[h];
                }

                var newItems = [];
                var tempId;

                var resultDataLen = result.data.length;

                for (var i = 0; i < resultDataLen; i++) {
                  tempId = result.data[i];
                  if (existingItemsMap[tempId] == null) {
                    newItems.push({id: tempId});
                  } else {
                    newItems.push(existingItemsMap[tempId]);
                  }
                }
                self.resourceValue = newItems;

                if (result.count != null) {
                  self.resourceCount = result.count;
                }
              }
              self.resourceIsLastPage = result.isLastPage;
            });
          };

          if (this.disableRealtime) {
            // This is to account for socket reconnects - After recovering from a lost connection,
            // we will re-fetch the whole value to make sure that we haven't missed any updates made to it.
            this.socket.on('connect', function (status) {
              self.loadData();
            });

            if (this.socket.state == 'open') {
              self.loadData();
            }
          } else {
            this.setupChannels();

            if (!this.viewChangeWatcher) {
              this.viewChangeWatcher = function (packet) {
                if (packet == null) {
                  self.reloadCurrentPage();
                } else {
                  var collectionStart = self.resourcePageOffset || 0;
                  var collectionEnd = collectionStart + self.resourcePageSize;
                  if (packet.offset <= collectionEnd) {
                    self.reloadCurrentPage();
                  }
                }
              };
              this.viewChannel.watch(this.viewChangeWatcher);
            }
            if (!this.optimize && !this.typeChangeWatcher) {
              this.typeChangeWatcher = function (packet) {
                self.reloadCurrentPage();
              };
              this.typeChannel.watch(this.typeChangeWatcher);
            }

            if (!this.resubscribe) {
              // This is needed to recover from lost authentication.
              this.resubscribe = function () {
                self.setupChannels();
              };
            }

            this.loadDataIfAllChannelsAreSubscribed = function () {
              if (self.viewChannel.state == 'subscribed' &&
                (self.optimize || self.typeChannel.state == 'subscribed')) {

                self.loadData();
              }
            };

            // Fetch data once the subscriptions are successful.
            if (this.viewChannel.listeners('subscribe')
              .indexOf(this.loadDataIfAllChannelsAreSubscribed) == -1) {

              this.viewChannel.on('subscribe', this.loadDataIfAllChannelsAreSubscribed);
            }
            if (!this.optimize &&
              this.typeChannel.listeners('subscribe')
              .indexOf(this.loadDataIfAllChannelsAreSubscribed) == -1) {

              this.typeChannel.on('subscribe', this.loadDataIfAllChannelsAreSubscribed);
            }
            this.loadDataIfAllChannelsAreSubscribed();

            if (this.socket.listeners('authenticate').indexOf(this.resubscribe) == -1) {
              this.socket.on('authenticate', this.resubscribe);
            }
          }

          this.isReady = true;
        }
      },

      realtimeModeObserver: function (newValue) {
        if (this.socket) {
          if (newValue) {
            this.cleanupChannels();
          } else {
            if (!this.writeOnly) {
              this.loadValueObserver();
            }
          }
        }
      },

      setupChannels: function () {
        var channelPrefix = 'crud>';
        var predicateDataString;
        if (this.resourcePredicateData == null) {
          predicateDataString = '';
        } else {
          predicateDataString = jsonStableStringify(this.resourcePredicateData);
        }
        var viewChannelName = channelPrefix + this.resourceView +
          '(' + predicateDataString + '):' + this.resourceType;

        if (this.viewChannel) {
          this.socket.subscribe(viewChannelName);
        } else {
          this.viewChannel = this.socket.subscribe(viewChannelName);
        }

        if (!this.optimize) {
          var typeChannelName = channelPrefix + this.resourceType;

          if (this.typeChannel) {
            this.socket.subscribe(typeChannelName);
          } else {
            this.typeChannel = this.socket.subscribe(typeChannelName);
          }
        }
      },

      cleanupChannels: function () {
        if (this.resubscribe) {
          this.socket.off('authenticate', this.resubscribe);
        }
        if (this.viewChannel) {
          if (this.loadDataIfAllChannelsAreSubscribed) {
            this.viewChannel.off('subscribe', this.loadDataIfAllChannelsAreSubscribed);
          }
          if (this.viewChangeWatcher) {
            this.viewChannel.unwatch(this.viewChangeWatcher);
            delete this.viewChangeWatcher;
          }
          if (!this.viewChannel.watchers().length) {
            this.viewChannel.unsubscribe();
          }
          delete this.viewChannel;
        }
        if (this.typeChannel) {
          if (this.loadDataIfAllChannelsAreSubscribed) {
            this.typeChannel.off('subscribe', this.loadDataIfAllChannelsAreSubscribed);
          }
          if (this.typeChangeWatcher) {
            this.typeChannel.unwatch(this.typeChangeWatcher);
            delete this.typeChangeWatcher;
          }
          if (!this.typeChannel.watchers().length) {
            this.typeChannel.unsubscribe();
          }
          delete this.typeChannel;
        }
      },

      detached: function () {
        this.cleanupChannels();
      },

      reloadCurrentPage: function () {
        if (!this.writeOnly) {
          this.loadValueObserver();
        }
      },

      fetchNextPage: function () {
        if (!this.resourceIsLastPage) {
          this.resourcePageOffset += this.resourcePageSize;
        }
      },

      fetchPreviousPage: function () {
        if (this.resourcePageOffset > 0) {
          var prevOffset = this.resourcePageOffset - this.resourcePageSize;
          if (prevOffset < 0) {
            prevOffset = 0;
          }
          this.resourcePageOffset = prevOffset;
        }
      },

      getOptimization: function () {
        var optimization = {};
        optimization[this.resourceView] = this.resourcePredicateData || null;
        return optimization;
      },

      create: function (newValue, callback) {
        var query = {
          type: this.resourceType,
          value: newValue
        };
        if (this.optimize) {
          query.optimization = this.getOptimization();
        }
        this.socket.emit('create', query, callback);
      },

      delete: function (callback) {
        this.resourceValue = null;

        var query = {
          type: this.resourceType,
          predicateData: this.resourcePredicateData
        };
        if (this.optimize) {
          query.optimization = this.getOptimization();
        }
        this.socket.emit('delete', query, callback);
      }
    });
  </script>
</dom-module>
