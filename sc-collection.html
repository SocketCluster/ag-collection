<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../sc-socket/sc-socket.html">
<link rel="import" href="../sc-json-stable-stringify/sc-json-stable-stringify.html">

<dom-module id="sc-collection">
  <template>
    <sc-socket socket="{{socket}}"></sc-socket>
  </template>

  <script>
    Polymer({
      is: 'sc-collection',

      properties: {
        resourceType: {
          type: String,
          observer: 'loadValueObserver'
        },
        resourceView: {
          type: String,
          observer: 'loadValueObserver'
        },
        resourceValue: {
          type: Array,
          value: [],
          notify: true
        },
        resourcePageOffset: {
          type: Number,
          value: 0,
          notify: true,
          observer: 'loadValueObserver'
        },
        resourcePageSize: {
          type: Number,
          value: 10,
          notify: true,
          observer: 'loadValueObserver'
        },
        resourceIsLastPage: {
          type: Boolean,
          notify: true
        },
        resourceViewParams: {
          type: Object,
          observer: 'loadValueObserver'
        },
        resourceViewPrimaryKeys: {
          type: Array,
          value: null,
          observer: 'loadValueObserver'
        },
        resourceCount: {
          type: Number,
          notify: true
        },
        getCount: {
          type: Boolean,
          value: true,
          observer: 'loadValueObserver'
        },
        disableRealtime: {
          type: Boolean,
          value: false,
          observer: 'realtimeModeObserver'
        },
        writeOnly: {
          type: Boolean,
          value: false,
          observer: 'loadValueObserver'
        },
        socket: {
          type: Object,
          observer: 'loadValueObserver'
        },
        viewChannel: {
          type: Object
        },
        isReady: {
          type: Boolean,
          computed: 'areInputsReady(socket, resourceType, resourceView, resourceViewParams, resourcePageOffset, resourcePageSize, getCount, writeOnly)'
        }
      },

      areInputsReady: function () {
        for (var i in arguments) {
          if (arguments.hasOwnProperty(i)) {
            if (arguments[i] === undefined) {
              return;
            }
          }
        }
        return true;
      },

      loadValueObserver: function () {
        if (this.isReady) {
          if (this.resourceViewPrimaryKeys == null) {
            this.resourceViewPrimaryKeys = Object.keys(this.resourceViewParams || {});
          } else {
            this.loadValue();
          }
        }
      },

      loadValue: function () {
        var self = this;

        if (this.writeOnly) {
          throw new Error('Cannot load values for an sc-collection declared as write-only');
        }

        if (this.socket) {
          this.cleanupChannels();

          // Load values for the collection.
          this.loadData = function () {
            var query = {
              type: self.resourceType
            };
            query.offset = self.resourcePageOffset || 0;
            if (self.resourceView != null) {
              query.view = self.resourceView;
            }
            if (self.resourceViewParams != null) {
              query.viewParams = self.resourceViewParams;
            }
            if (self.resourcePageSize) {
              query.pageSize = self.resourcePageSize;
            }
            if (self.getCount) {
              query.getCount = true;
            }

            self.socket.emit('read', query, function (err, result) {
              if (err) {
                throw new Error(err);
              } else {
                var existingItemsMap = {};
                var currentItems = self.resourceValue;
                var len = currentItems.length;

                for (var h = 0; h < len; h++) {
                  existingItemsMap[currentItems[h].id] = currentItems[h];
                }

                var newItems = [];
                var tempId;

                var resultDataLen = result.data.length;

                for (var i = 0; i < resultDataLen; i++) {
                  tempId = result.data[i];
                  if (existingItemsMap[tempId] == null) {
                    newItems.push({id: tempId});
                  } else {
                    newItems.push(existingItemsMap[tempId]);
                  }
                }
                self.resourceValue = newItems;

                if (result.count != null) {
                  self.resourceCount = result.count;
                }
              }
              self.resourceIsLastPage = result.isLastPage;
            });
          };

          if (this.disableRealtime) {
            // This is to account for socket reconnects - After recovering from a lost connection,
            // we will re-fetch the whole value to make sure that we haven't missed any updates made to it.
            this.socket.on('connect', function (status) {
              self.loadData();
            });

            if (this.socket.state == 'open') {
              self.loadData();
            }
          } else {
            this.setupChannels();

            if (!this.viewChangeWatcher) {
              this.viewChangeWatcher = function (packet) {
                if (packet == null) {
                  self.reloadCurrentPage();
                } else {
                  var collectionStart = self.resourcePageOffset || 0;
                  var collectionEnd = collectionStart + self.resourcePageSize;
                  if (packet.type == 'update' && packet.action == 'move') {
                    // A resource was moved around within the same view as a result
                    // of an update operation on the resource.
                    var minOffset = Math.min(packet.oldOffset, packet.newOffset);
                    if (minOffset <= collectionEnd) {
                      self.reloadCurrentPage();
                    }
                  } else {
                    if (packet.offset <= collectionEnd) {
                      self.reloadCurrentPage();
                    }
                  }
                }
              };
              this.viewChannel.watch(this.viewChangeWatcher);
            }

            if (!this.resubscribe) {
              // This is needed to recover from lost authentication.
              this.resubscribe = function () {
                self.setupChannels();
              };
            }

            this.loadDataIfAllChannelsAreSubscribed = function () {
              if (self.viewChannel.state == 'subscribed') {
                self.loadData();
              }
            };

            // Fetch data once the subscriptions are successful.
            if (this.viewChannel.listeners('subscribe')
              .indexOf(this.loadDataIfAllChannelsAreSubscribed) == -1) {

              this.viewChannel.on('subscribe', this.loadDataIfAllChannelsAreSubscribed);
            }
            this.loadDataIfAllChannelsAreSubscribed();

            if (this.socket.listeners('authenticate').indexOf(this.resubscribe) == -1) {
              this.socket.on('authenticate', this.resubscribe);
            }
          }
        }
      },

      realtimeModeObserver: function (newValue) {
        if (this.socket) {
          if (newValue) {
            this.cleanupChannels();
          } else {
            if (!this.writeOnly) {
              this.loadValueObserver();
            }
          }
        }
      },

      setupChannels: function () {
        var channelPrefix = 'crud>';
        var resourceViewParamsObject = this.resourceViewParams || {};
        var viewParams = {};

        (this.resourceViewPrimaryKeys || []).forEach(function (fieldName) {
          viewParams[fieldName] = resourceViewParamsObject[fieldName];
        });
        var resourceViewParamsString = jsonStableStringify(viewParams);
        var viewChannelName = channelPrefix + this.resourceView +
          '(' + resourceViewParamsString + '):' + this.resourceType;

        var subscribeOptions = {
          data: {
            viewParams: resourceViewParamsObject
          }
        };

        if (this.viewChannel) {
          this.socket.subscribe(viewChannelName, subscribeOptions);
        } else {
          this.viewChannel = this.socket.subscribe(viewChannelName, subscribeOptions);
        }
      },

      cleanupChannels: function () {
        if (this.resubscribe) {
          this.socket.off('authenticate', this.resubscribe);
        }
        if (this.viewChannel) {
          if (this.loadDataIfAllChannelsAreSubscribed) {
            this.viewChannel.off('subscribe', this.loadDataIfAllChannelsAreSubscribed);
          }
          if (this.viewChangeWatcher) {
            this.viewChannel.unwatch(this.viewChangeWatcher);
            delete this.viewChangeWatcher;
          }
          if (!this.viewChannel.watchers().length) {
            this.viewChannel.unsubscribe();
          }
          delete this.viewChannel;
        }
      },

      detached: function () {
        this.cleanupChannels();
      },

      reloadCurrentPage: function () {
        if (!this.writeOnly) {
          this.loadValueObserver();
        }
      },

      fetchNextPage: function () {
        if (!this.resourceIsLastPage) {
          this.resourcePageOffset += this.resourcePageSize;
        }
      },

      fetchPreviousPage: function () {
        if (this.resourcePageOffset > 0) {
          var prevOffset = this.resourcePageOffset - this.resourcePageSize;
          if (prevOffset < 0) {
            prevOffset = 0;
          }
          this.resourcePageOffset = prevOffset;
        }
      },

      create: function (newValue, callback) {
        var query = {
          type: this.resourceType,
          value: newValue
        };
        this.socket.emit('create', query, callback);
      },

      delete: function (callback) {
        this.resourceValue = null;

        var query = {
          type: this.resourceType
        };
        this.socket.emit('delete', query, callback);
      }
    });
  </script>
</dom-module>
